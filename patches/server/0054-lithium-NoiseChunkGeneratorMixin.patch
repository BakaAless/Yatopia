From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: SuperCoder79 <k.pranav@gmail.com>
Date: Sat, 26 Sep 2020 14:25:07 -0500
Subject: [PATCH] lithium NoiseChunkGeneratorMixin

Original code by JellySquid, licensed under LGPLv3
you can find the original code on https://github.com/jellysquid3/lithium-fabric/ (Yarn mappings)

diff --git a/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java b/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
index 119804e5c12aca3f4fbfeaf424f46152f43b3941..3ba2844ac7e9d8e49fa42a9da6f0af021b12dd8a 100644
--- a/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
+++ b/src/main/java/net/minecraft/server/ChunkGeneratorAbstract.java
@@ -112,6 +112,97 @@ public final class ChunkGeneratorAbstract extends ChunkGenerator {
         return this.w == i && ((GeneratorSettingBase) this.h.get()).a(resourcekey);
     }
 
+    private static double sampleOctave(NoiseGeneratorPerlin sampler, double x, double y, double z, double scaledVerticalScale, double scaledY, double frequency) {
+        return sampler.sample(x, y, z, scaledVerticalScale, scaledY) / frequency;
+    }
+
+    private double sampleNoise(int x, int y, int z, double horizontalScale, double verticalScale, double horizontalStretch, double verticalStretch) { return a(x, y, z, horizontalScale, verticalScale, horizontalStretch, verticalStretch); } // Yatopia - OBFHELPER
+    private double a(int x, int y, int z, double horizontalScale, double verticalScale, double horizontalStretch, double verticalStretch) {
+        // To generate it's terrain, Minecraft uses two different perlin noises.
+        // It interpolates these two noises to create the final sample at a position.
+        // However, the interpolation noise is not all that good and spends most of it's time at > 1 or < 0, rendering
+        // one of the noises completely unnecessary in the process.
+        // By taking advantage of that, we can reduce the sampling needed per block through the interpolation noise.
+
+        // This controls both the frequency and amplitude of the noise.
+        double frequency = 1.0;
+        double interpolationValue = 0.0;
+
+        // Calculate interpolation data to decide what noise to sample.
+        for (int octave = 0; octave < 8; octave++) {
+            double scaledVerticalScale = verticalStretch * frequency;
+            double scaledY = y * scaledVerticalScale;
+
+            interpolationValue += sampleOctave(this.s.a(octave),
+                    NoiseGeneratorOctaves.a(x * horizontalStretch * frequency),
+                    NoiseGeneratorOctaves.a(scaledY),
+                    NoiseGeneratorOctaves.a(z * horizontalStretch * frequency), scaledVerticalScale, scaledY, frequency);
+
+            frequency /= 2.0;
+        }
+
+        double clampedInterpolation = (interpolationValue / 10.0 + 1.0) / 2.0;
+
+        if (clampedInterpolation >= 1) {
+            // Sample only upper noise, as the lower noise will be interpolated out.
+            frequency = 1.0;
+            double noise = 0.0;
+            for (int octave = 0; octave < 16; octave++) {
+                double scaledVerticalScale = verticalScale * frequency;
+                double scaledY = y * scaledVerticalScale;
+
+                noise += sampleOctave(this.r.a(octave),
+                        NoiseGeneratorOctaves.a(x * horizontalScale * frequency),
+                        NoiseGeneratorOctaves.a(scaledY),
+                        NoiseGeneratorOctaves.a(z * horizontalScale * frequency), scaledVerticalScale, scaledY, frequency);
+
+                frequency /= 2.0;
+            }
+
+            return noise / 512.0;
+        } else if (clampedInterpolation <= 0) {
+            // Sample only lower noise, as the upper noise will be interpolated out.
+            frequency = 1.0;
+            double noise = 0.0;
+            for (int octave = 0; octave < 16; octave++) {
+                double scaledVerticalScale = verticalScale * frequency;
+                double scaledY = y * scaledVerticalScale;
+                noise += sampleOctave(this.q.a(octave),
+                        NoiseGeneratorOctaves.a(x * horizontalScale * frequency),
+                        NoiseGeneratorOctaves.a(scaledY),
+                        NoiseGeneratorOctaves.a(z * horizontalScale * frequency), scaledVerticalScale, scaledY, frequency);
+
+                frequency /= 2.0;
+            }
+
+            return noise / 512.0;
+        } else {
+            // [VanillaCopy] SurfaceChunkGenerator#sampleNoise
+            // Sample both and interpolate, as in vanilla.
+
+            frequency = 1.0;
+            double lowerNoise = 0.0;
+            double upperNoise = 0.0;
+
+            for (int octave = 0; octave < 16; octave++) {
+                // Pre calculate these values to share them
+                double scaledVerticalScale = verticalScale * frequency;
+                double scaledY = y * scaledVerticalScale;
+                double xVal = NoiseGeneratorOctaves.a(x * horizontalScale * frequency);
+                double yVal = NoiseGeneratorOctaves.a(scaledY);
+                double zVal = NoiseGeneratorOctaves.a(z * horizontalScale * frequency);
+
+                upperNoise += sampleOctave(this.r.a(octave), xVal, yVal, zVal, scaledVerticalScale, scaledY, frequency);
+                lowerNoise += sampleOctave(this.q.a(octave), xVal, yVal, zVal, scaledVerticalScale, scaledY, frequency);
+
+                frequency /= 2.0;
+            }
+
+            // Vanilla behavior, return interpolated noise
+            return MathHelper.b(clampedInterpolation, lowerNoise / 512.0, upperNoise / 512.0);
+        }
+    }
+    /* //Yatopa Start - Replace Logic
     private double a(int i, int j, int k, double d0, double d1, double d2, double d3) {
         double d4 = 0.0D;
         double d5 = 0.0D;
@@ -148,7 +239,7 @@ public final class ChunkGeneratorAbstract extends ChunkGenerator {
         }
 
         return MathHelper.b(d4 / 512.0D, d5 / 512.0D, (d6 / 10.0D + 1.0D) / 2.0D);
-    }
+    }*/ //Yatopia End
 
     private double[] b(int i, int j) {
         double[] adouble = new double[this.o + 1];
