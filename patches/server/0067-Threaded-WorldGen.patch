From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sat, 9 Jan 2021 19:21:16 +0800
Subject: [PATCH] Threaded WorldGen

A massive improvement to world generation.
This patch actually schedules chunk status upgrade later rather than doing it right away.
However, feature placements are still on the server thread for now.

diff --git a/pom.xml b/pom.xml
index dd20e7924a233e5539ef288a1521d71cff2d4a16..85ace2333c7bb70e62b70c2625fee7cb52addfac 100644
--- a/pom.xml
+++ b/pom.xml
@@ -191,6 +191,12 @@
             <artifactId>jocl-main</artifactId>
             <version>2.3.2</version>
         </dependency>
+        <!-- https://mvnrepository.com/artifact/com.ibm.async/asyncutil -->
+        <dependency>
+            <groupId>com.ibm.async</groupId>
+            <artifactId>asyncutil</artifactId>
+            <version>0.1.0</version>
+        </dependency>
     </dependencies>
 
     <repositories>
diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java
index 17cf00dfe8b24adf2fb66eca4710ab7888a894e3..48cebf3b811f579d75bfaac5a72f9d6aa3e11f85 100644
--- a/src/main/java/net/minecraft/server/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/server/ChunkGenerator.java
@@ -20,6 +20,8 @@ public abstract class ChunkGenerator {
     private final StructureSettings structureSettings;
     private final long e;
     private final List<ChunkCoordIntPair> f;
+    public final com.ibm.asyncutil.locks.AsyncLock featureGenLock = com.ibm.asyncutil.locks.AsyncLock.createFair(); // Yatopia - threaded WorldGen
+    public final com.ibm.asyncutil.locks.AsyncLock structureGenLock = com.ibm.asyncutil.locks.AsyncLock.createFair(); // Yatopia - threaded WorldGen
 
     public ChunkGenerator(WorldChunkManager worldchunkmanager, StructureSettings structuresettings) {
         this(worldchunkmanager, worldchunkmanager, structuresettings, 0L);
diff --git a/src/main/java/net/minecraft/server/ChunkStatus.java b/src/main/java/net/minecraft/server/ChunkStatus.java
index 51ea295d66312c95685b9fe4ee502a029d2fff20..4afba15d01e86e64ddec3f599a04b7f9afd20b91 100644
--- a/src/main/java/net/minecraft/server/ChunkStatus.java
+++ b/src/main/java/net/minecraft/server/ChunkStatus.java
@@ -9,11 +9,51 @@ import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
+// Yatopia start
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+// Yatopia end
 import java.util.function.Function;
 import javax.annotation.Nullable;
 
 public class ChunkStatus {
 
+    // Yatopia start - threaded WorldGen
+    private static final ThreadPoolExecutor featureGenExecutor = new ThreadPoolExecutor(
+            2,
+            Math.min(Runtime.getRuntime().availableProcessors(), Integer.getInteger("paper.maxChunkThreads", 8)),
+            60,
+            TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks FeatureGen Worker #%d").build()
+    );
+    private static final ThreadPoolExecutor structureGenExecutor = new ThreadPoolExecutor(
+            1,
+            Math.min(Runtime.getRuntime().availableProcessors(), Integer.getInteger("paper.maxChunkThreads", 8)),
+            60,
+            TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks StructureGen Worker #%d").build()
+    );
+    static void shutdownExecutors() {
+        featureGenExecutor.shutdown();
+        structureGenExecutor.shutdown();
+        while (!featureGenExecutor.isTerminated()) {
+            try {
+                featureGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+        while (!structureGenExecutor.isTerminated()) {
+            try {
+                structureGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+
+    }
+    // Yatopia end
     private static final EnumSet<HeightMap.Type> n = EnumSet.of(HeightMap.Type.OCEAN_FLOOR_WG, HeightMap.Type.WORLD_SURFACE_WG);
     private static final EnumSet<HeightMap.Type> o = EnumSet.of(HeightMap.Type.OCEAN_FLOOR, HeightMap.Type.WORLD_SURFACE, HeightMap.Type.MOTION_BLOCKING, HeightMap.Type.MOTION_BLOCKING_NO_LEAVES);
     private static final ChunkStatus.c p = (chunkstatus, worldserver, definedstructuremanager, lightenginethreaded, function, ichunkaccess) -> {
@@ -26,6 +66,9 @@ public class ChunkStatus {
     public static final ChunkStatus EMPTY = a("empty", (ChunkStatus) null, -1, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (worldserver, chunkgenerator, list, ichunkaccess) -> {
     });
     public static final ChunkStatus STRUCTURE_STARTS = a("structure_starts", ChunkStatus.EMPTY, 0, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        // Yatopia start - threaded WorldGen
+        return chunkgenerator.structureGenLock.acquireLock().toCompletableFuture().thenComposeAsync(lockToken -> {
+        try {
         if (!ichunkaccess.getChunkStatus().b(chunkstatus)) {
             if (worldserver.worldDataServer.getGeneratorSettings().shouldGenerateMapFeatures()) { // CraftBukkit
                 chunkgenerator.createStructures(worldserver.r(), worldserver.getStructureManager(), ichunkaccess, definedstructuremanager, worldserver.getSeed());
@@ -35,8 +78,12 @@ public class ChunkStatus {
                 ((ProtoChunk) ichunkaccess).a(chunkstatus);
             }
         }
-
+        } finally {
+            lockToken.releaseLock();
+        }
         return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+        }, structureGenExecutor);
+        // Yatopia end
     });
     public static final ChunkStatus STRUCTURE_REFERENCES = a("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (worldserver, chunkgenerator, list, ichunkaccess) -> {
         RegionLimitedWorldAccess regionlimitedworldaccess = new RegionLimitedWorldAccess(worldserver, list);
@@ -61,6 +108,9 @@ public class ChunkStatus {
         chunkgenerator.doCarving(worldserver.getSeed(), worldserver.d(), ichunkaccess, WorldGenStage.Features.LIQUID);
     });
     public static final ChunkStatus FEATURES = a("features", ChunkStatus.LIQUID_CARVERS, 8, ChunkStatus.o, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        // Yatopia start - threaded WorldGen
+        return chunkgenerator.featureGenLock.acquireLock().toCompletableFuture().thenComposeAsync(token -> {
+        try {
         ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
 
         protochunk.a((LightEngine) lightenginethreaded);
@@ -71,8 +121,13 @@ public class ChunkStatus {
             chunkgenerator.addDecorations(regionlimitedworldaccess, worldserver.getStructureManager().a(regionlimitedworldaccess));
             protochunk.a(chunkstatus);
         }
+        } finally {
+            token.releaseLock();
+        }
 
         return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+        }, featureGenExecutor);
+        // Yatopia end
     });
     public static final ChunkStatus LIGHT = a("light", ChunkStatus.FEATURES, 1, ChunkStatus.o, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
         return a(chunkstatus, lightenginethreaded, ichunkaccess);
@@ -245,14 +300,18 @@ public class ChunkStatus {
 
         @Override
         default CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> doWork(ChunkStatus chunkstatus, WorldServer worldserver, ChunkGenerator chunkgenerator, DefinedStructureManager definedstructuremanager, LightEngineThreaded lightenginethreaded, Function<IChunkAccess, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function, List<IChunkAccess> list, IChunkAccess ichunkaccess) {
+            // Yatopia start - threaded worldGen
+            return CompletableFuture.supplyAsync(() -> {
             if (!ichunkaccess.getChunkStatus().b(chunkstatus)) {
                 this.doWork(worldserver, chunkgenerator, list, ichunkaccess);
                 if (ichunkaccess instanceof ProtoChunk) {
                     ((ProtoChunk) ichunkaccess).a(chunkstatus);
                 }
             }
+            return Either.left(ichunkaccess);
+            }, SystemUtils.getMainThreadExecutor());
 
-            return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+            // Yatopia end
         }
 
         void doWork(WorldServer worldserver, ChunkGenerator chunkgenerator, List<IChunkAccess> list, IChunkAccess ichunkaccess);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 784252aa38bddd23bbbce8ffa66ae76149fe3a84..ac794dc404835bf25a8334ebd43bd651eff86273 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -835,6 +835,8 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         LOGGER.info("Flushing Chunk IO");
         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
         LOGGER.info("Closing Thread Pool");
+        PlayerChunkMap.shutdownScheduler(); // Yatopia
+        ChunkStatus.shutdownExecutors(); // Yatopia
         SystemUtils.shutdownServerThreadPool(); // Paper
         LOGGER.info("Closing Server");
         org.yatopiamc.yatopia.server.opencl.OpenCompute.release(); // Yatopia
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 16779ffa00caf32752170700e1d88092802fa932..fe91674b589852583852da2e7b5d4bddfa675718 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -8,6 +8,7 @@ import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
@@ -57,6 +58,18 @@ import org.spigotmc.AsyncCatcher;
 
 public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
+    // Yatopia start
+    static final java.util.concurrent.ExecutorService worldGenScheduler = java.util.concurrent.Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("Yatopia Async Chunks Scheduler").setDaemon(true).setPriority(Thread.NORM_PRIORITY - 1).build());
+    static void shutdownScheduler() {
+        worldGenScheduler.shutdown();
+        while (!worldGenScheduler.isTerminated()) {
+            try {
+                worldGenScheduler.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+    }
+    // Yatopia end
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
     // Paper start - faster copying
@@ -1320,7 +1333,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 return;
             }
             // Paper end
-            this.mailboxWorldGen.a(ChunkTaskQueueSorter.a(playerchunk, runnable));
+            worldGenScheduler.execute(runnable); // Yatopia
         }).thenComposeAsync((either) -> { // Tuinity start - force competion on the main thread
             return CompletableFuture.completedFuture(either);
         }, this.mainInvokingExecutor);
diff --git a/src/main/java/net/minecraft/server/SystemUtils.java b/src/main/java/net/minecraft/server/SystemUtils.java
index 61d399077f87fc1f198811ee31fc779b6f0ecfa9..98ec9db831697f59ddbefaee7e22d01888082485 100644
--- a/src/main/java/net/minecraft/server/SystemUtils.java
+++ b/src/main/java/net/minecraft/server/SystemUtils.java
@@ -115,6 +115,7 @@ public class SystemUtils {
         return SystemUtils.d;
     }
 
+    public static Executor getMainThreadExecutor() { return f(); } // Yatopia - OBFHELPER
     public static Executor f() {
         return SystemUtils.e;
     }
