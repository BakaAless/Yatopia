From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sun, 15 Nov 2020 10:42:27 +0800
Subject: [PATCH] Multi-threaded RegionFile IO


diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index 1917d7be7dfddc93c95b9fd864cf13f9a24c8f96..874b0ff16eabca1b0c39a275e194c93aa620c478 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -35,7 +35,7 @@ import java.util.function.Function;
  * @see #scheduleSave(WorldServer, int, int, NBTTagCompound, NBTTagCompound, int)
  * @see #loadChunkDataAsync(WorldServer, int, int, int, Consumer, boolean, boolean, boolean)
  */
-public final class PaperFileIOThread extends QueueExecutorThread {
+public final class PaperFileIOThread { // Yatopia
 
     public static final Logger LOGGER = MinecraftServer.LOGGER;
     public static final NBTTagCompound FAILURE_VALUE = new NBTTagCompound();
@@ -44,23 +44,76 @@ public final class PaperFileIOThread extends QueueExecutorThread {
 
         public static final PaperFileIOThread INSTANCE = new PaperFileIOThread();
 
+        /* Yatopia
         static {
             INSTANCE.start();
         }
+        */
     }
 
     private final AtomicLong writeCounter = new AtomicLong();
+    // Yatopia start - multi-threaded RegionFile IO
+    private final com.ibm.asyncutil.locks.AsyncNamedLock<RegionFileCoord> regionFileLock = com.ibm.asyncutil.locks.AsyncNamedLock.createFair();
+    private final PrioritizedTaskQueue<PrioritizedTaskQueue.PrioritizedTask> queue;
+    private final QueueExecutorThread receiver;
+    private final java.util.Set<Thread> executorThreads = com.google.common.collect.Sets.newConcurrentHashSet();
+    private final java.util.concurrent.ExecutorService executor = java.util.concurrent.Executors.newFixedThreadPool(
+            Math.min(Runtime.getRuntime().availableProcessors(), Integer.getInteger("paper.maxChunkThreads", 8)),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder()
+                    .setNameFormat("Paper RegionFile IO Worker #%d")
+                    .setPriority(Thread.NORM_PRIORITY - 1)
+                    .setDaemon(true)
+                    .setThreadFactory(r -> {
+                        Thread thr = new Thread(r);
+                        executorThreads.add(thr);
+                        return thr;
+                    })
+                    .setUncaughtExceptionHandler((t, e) -> {
+                        LOGGER.fatal("Uncaught exception thrown from " + t.getName() + ", report this!", e);
+                        executorThreads.remove(t);
+                    })
+                    .build()
+    );
 
     private PaperFileIOThread() {
-        super(new PrioritizedTaskQueue<>(), (int)(1.0e6)); // 1.0ms spinwait time
-        this.setName("Paper RegionFile IO Thread");
-        this.setPriority(Thread.NORM_PRIORITY - 1); // we keep priority close to normal because threads can wait on us
-        this.setUncaughtExceptionHandler((final Thread unused, final Throwable thr) -> {
-            LOGGER.fatal("Uncaught exception thrown from IO thread, report this!", thr);
+        queue = new PrioritizedTaskQueue<>();
+        receiver = new PaperFileIOThread.FileIOExecutorThread(queue, (int) (1.0e6)); // 1.0ms spinwait time
+        receiver.setName("Paper RegionFile IO Task Receiver");
+        receiver.setPriority(Thread.NORM_PRIORITY - 1); // we keep priority close to normal because threads can wait on us
+        receiver.setUncaughtExceptionHandler((final Thread thread, final Throwable thr) -> {
+            LOGGER.fatal("Uncaught exception thrown from " + thread.getName() + ", report this!", thr);
         });
+        receiver.start();
+
+    }
+
+    public void flush() {
+        receiver.flush();
+    }
+
+    private void queueTask(PrioritizedTaskQueue.PrioritizedTask newTask) {
+        queue.add(newTask);
+        receiver.notifyTasks();
+    }
+
+    public void close(final boolean wait) {
+        receiver.close(wait, false);
+        queue.shutdown();
+        executor.shutdown();
+        while (wait && !executor.isTerminated()) {
+            try {
+                executor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS);
+            } catch (InterruptedException e) {
+            }
+        }
     }
 
-    /* run() is implemented by superclass */
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
+    public boolean isOnWorkerThread() {
+        return executorThreads.contains(Thread.currentThread());
+    }
+
+    // Yatopia end
 
     /*
      *
@@ -394,6 +447,79 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         this.queueTask(new GeneralTask(priority, runnable));
     }
 
+    // Yatopia start
+    static final class RegionFileCoord {
+
+        public final int x;
+        public final int z;
+
+        RegionFileCoord(int x, int z) {
+            this.x = x;
+            this.z = z;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            RegionFileCoord that = (RegionFileCoord) o;
+            return x == that.x && z == that.z;
+        }
+
+        @Override
+        public int hashCode() {
+            return java.util.Objects.hash(x, z);
+        }
+    }
+
+    final class FileIOExecutorThread<T extends PrioritizedTaskQueue.PrioritizedTask & Runnable> extends QueueExecutorThread<T> {
+
+        public FileIOExecutorThread(PrioritizedTaskQueue<T> queue, long spinWaitTime) {
+            super(queue, spinWaitTime);
+        }
+
+        @Override
+        protected boolean pollTasks(boolean flushTasks) {
+            Runnable task;
+            boolean ret = false;
+
+            while ((task = this.queue.poll()) != null) {
+                ret = true;
+                if (task instanceof ChunkDataTask) {
+                    ChunkDataTask chunkDataTask = (ChunkDataTask) task;
+                    regionFileLock.acquireLock(new RegionFileCoord(chunkDataTask.x >> 5, chunkDataTask.z >> 5))
+                            .thenApplyAsync(lockToken -> {
+                                try {
+                                    chunkDataTask.run();
+                                } finally {
+                                    lockToken.releaseLock();
+                                }
+                                return null;
+                            }, executor)
+                    .exceptionally(throwable -> {
+                        LOGGER.fatal("Exception thrown from prioritized runnable task in thread '" + Thread.currentThread().getName() + "': " + IOUtil.genericToString(chunkDataTask), throwable);
+                        return null;
+                    });
+                } else {
+                    Runnable finalTask = task;
+                    CompletableFuture.supplyAsync(() -> {
+                        finalTask.run();
+                        return null;
+                    }).exceptionally(throwable -> {
+                        LOGGER.fatal("Exception thrown from prioritized runnable task in thread '" + Thread.currentThread().getName() + "': " + IOUtil.genericToString(finalTask), throwable);
+                        return null;
+                    });
+                }
+            }
+
+            if (flushTasks) {
+                this.handleFlushThreads(false);
+            }
+
+            return ret;
+        }
+    }
+    // Yatopia end
     static final class GeneralTask extends PrioritizedTaskQueue.PrioritizedTask implements Runnable {
 
         private final Runnable run;
diff --git a/src/main/java/com/destroystokyo/paper/io/QueueExecutorThread.java b/src/main/java/com/destroystokyo/paper/io/QueueExecutorThread.java
index ee906b594b306906c170180a29a8b61997d05168..8eab86b48679e23ca084e51f08959a1cc112e8a3 100644
--- a/src/main/java/com/destroystokyo/paper/io/QueueExecutorThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/QueueExecutorThread.java
@@ -81,7 +81,7 @@ public class QueueExecutorThread<T extends PrioritizedTaskQueue.PrioritizedTask
             // LockSupport.park() can fail for any reason
             do {
                 Thread.interrupted();
-                LockSupport.park("Waiting on tasks");
+                LockSupport.parkNanos("Waiting on tasks", 1_000_000_000); // Yatopia - prevent dead lock
             } while (this.parked.get());
         }
     }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 784252aa38bddd23bbbce8ffa66ae76149fe3a84..3b8da11cbd8c800f9fb59a8b169959b11fdee9a9 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -833,7 +833,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         // Spigot end
         // Paper start - move final shutdown items here
         LOGGER.info("Flushing Chunk IO");
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true, true); // Paper
+        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true); // Paper // Yatopia
         LOGGER.info("Closing Thread Pool");
         SystemUtils.shutdownServerThreadPool(); // Paper
         LOGGER.info("Closing Server");
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 16779ffa00caf32752170700e1d88092802fa932..61e0a1bee4740cb82e96af8bde066cd4578d947a 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -1688,7 +1688,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     @Nullable
     @Override
     public NBTTagCompound read(ChunkCoordIntPair chunkcoordintpair) throws IOException {
-        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+        if (!com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.isOnWorkerThread()) { // Yatopia
             NBTTagCompound ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
                 .loadChunkDataAsyncFuture(this.world, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
                     false, true, true).join().chunkData;
@@ -1703,7 +1703,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Override
     public void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
-        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+        if (!com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.isOnWorkerThread()) { // Yatopia
             com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
                 this.world, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
                 com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - writes are async, no need for priority
diff --git a/src/main/java/net/minecraft/server/VillagePlace.java b/src/main/java/net/minecraft/server/VillagePlace.java
index 24d7c31f710b4d13489ea77cf14acdd368c8aecd..e37561869e6fcf7af96cc485ff5a31fb33e35e8a 100644
--- a/src/main/java/net/minecraft/server/VillagePlace.java
+++ b/src/main/java/net/minecraft/server/VillagePlace.java
@@ -535,7 +535,7 @@ public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
     @javax.annotation.Nullable
     @Override
     public NBTTagCompound read(ChunkCoordIntPair chunkcoordintpair) throws java.io.IOException {
-        if (this.world != null && Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+        if (this.world != null && !com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.isOnWorkerThread()) { // Yatopia
             NBTTagCompound ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
                 .loadChunkDataAsyncFuture(this.world, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
                     true, false, true).join().poiData;
@@ -550,7 +550,7 @@ public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
 
     @Override
     public void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws java.io.IOException {
-        if (this.world != null && Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+        if (this.world != null && !com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.isOnWorkerThread()) { // Yatopia
             com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
                 this.world, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound, null,
                 com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - writes are async, no need for priority
