From 79547b24d9b7e0b0b16d3916afb244b223c96030 Mon Sep 17 00:00:00 2001
From: tr7zw <tr7zw@live.de>
Date: Mon, 9 Mar 2020 18:49:50 +0100
Subject: [PATCH] Option for async world ticking

---
 .../java/de/tr7zw/yapfa/YapfaCommand.java     |   2 +
 src/main/java/de/tr7zw/yapfa/YapfaConfig.java |   5 +
 .../minecraft/server/ChunkMapDistance.java    |  76 +++++----
 .../minecraft/server/ChunkProviderServer.java |   2 +-
 .../minecraft/server/EntityTrackerEntry.java  |   2 +-
 .../net/minecraft/server/MinecraftServer.java | 141 ++++++++++++-----
 .../net/minecraft/server/PlayerChunkMap.java  |   7 +-
 .../server/PlayerConnectionUtils.java         |  12 +-
 src/main/java/net/minecraft/server/World.java |   8 +-
 .../net/minecraft/server/WorldServer.java     |  44 +++++-
 .../org/bukkit/craftbukkit/CraftWorld.java    |  39 +++--
 .../craftbukkit/util/WeakCollection.java      | 148 ++++++++++--------
 12 files changed, 319 insertions(+), 167 deletions(-)

diff --git a/src/main/java/de/tr7zw/yapfa/YapfaCommand.java b/src/main/java/de/tr7zw/yapfa/YapfaCommand.java
index 58ce1f826..ed987cd15 100644
--- a/src/main/java/de/tr7zw/yapfa/YapfaCommand.java
+++ b/src/main/java/de/tr7zw/yapfa/YapfaCommand.java
@@ -113,6 +113,8 @@ public class YapfaCommand extends Command {
 
     private void doInfo(CommandSender sender) {
         Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Last tick took " + Bukkit.getLastTickMs() + "ms");
+        Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Async world ticking: " + MinecraftServer.asyncWorlds);
+        Command.broadcastCommandMessage(sender, ChatColor.GREEN + "The worlds where ticking for " + MinecraftServer.worldTick + "ms");
         //TODO
     }
 
diff --git a/src/main/java/de/tr7zw/yapfa/YapfaConfig.java b/src/main/java/de/tr7zw/yapfa/YapfaConfig.java
index 71c04cf49..ce8ff835b 100644
--- a/src/main/java/de/tr7zw/yapfa/YapfaConfig.java
+++ b/src/main/java/de/tr7zw/yapfa/YapfaConfig.java
@@ -216,4 +216,9 @@ public class YapfaConfig {
     	disableEntityCollisionboxes = getBoolean("settings.disableEntityCollisionboxes", false);
     }
     
+    public static boolean asyncWorldTick = false;
+    private static void asyncWorldTick() {
+    	asyncWorldTick = getBoolean("settings.asyncWorldTick", false);
+    }
+    
 }
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 73d157076..f4f60abb7 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -54,21 +54,23 @@ public abstract class ChunkMapDistance {
 
     protected void purgeTickets() {
         ++this.currentTick;
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
+        synchronized (tickets) {
+        	ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
-        while (objectiterator.hasNext()) {
-            Entry<ArraySetSorted<Ticket<?>>> entry = (Entry) objectiterator.next();
+            while (objectiterator.hasNext()) {
+                Entry<ArraySetSorted<Ticket<?>>> entry = (Entry) objectiterator.next();
 
-            if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
-                return ticket.b(this.currentTick);
-            })) {
-                this.e.b(entry.getLongKey(), a((ArraySetSorted) entry.getValue()), false);
-            }
+                if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
+                    return ticket == null || ticket.b(this.currentTick); // YAPFA
+                })) {
+                    this.e.b(entry.getLongKey(), a((ArraySetSorted) entry.getValue()), false);
+                }
 
-            if (((ArraySetSorted) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
+                if (((ArraySetSorted) entry.getValue()).isEmpty()) {
+                    objectiterator.remove();
+                }
             }
-        }
+		}
 
     }
 
@@ -157,7 +159,9 @@ public abstract class ChunkMapDistance {
         }
 
         if (arraysetsorted.isEmpty()) {
-            this.tickets.remove(i);
+        	synchronized (tickets) {
+        		this.tickets.remove(i);
+        	}
         }
 
         this.e.b(i, a(arraysetsorted), false);
@@ -197,9 +201,11 @@ public abstract class ChunkMapDistance {
     }
 
     private ArraySetSorted<Ticket<?>> e(long i) {
-        return (ArraySetSorted) this.tickets.computeIfAbsent(i, (j) -> {
-            return ArraySetSorted.a(4);
-        });
+    	synchronized (tickets) {
+	        return (ArraySetSorted) this.tickets.computeIfAbsent(i, (j) -> {
+	            return ArraySetSorted.a(4);
+	        });
+    	}
     }
 
     protected void a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
@@ -237,16 +243,18 @@ public abstract class ChunkMapDistance {
     }
 
     protected String c(long i) {
-        ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) this.tickets.get(i);
-        String s;
+    	synchronized (tickets) {
+    		ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) this.tickets.get(i);
+            String s;
 
-        if (arraysetsorted != null && !arraysetsorted.isEmpty()) {
-            s = ((Ticket) arraysetsorted.b()).toString();
-        } else {
-            s = "no_ticket";
-        }
+            if (arraysetsorted != null && !arraysetsorted.isEmpty()) {
+                s = ((Ticket) arraysetsorted.b()).toString();
+            } else {
+                s = "no_ticket";
+            }
 
-        return s;
+            return s;
+		}
     }
 
     protected void a(int i) {
@@ -271,13 +279,15 @@ public abstract class ChunkMapDistance {
     public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
         Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
 
-        for (java.util.Iterator<ArraySetSorted<Ticket<?>>> iterator = this.tickets.values().iterator(); iterator.hasNext();) {
-            ArraySetSorted<Ticket<?>> tickets = iterator.next();
-            tickets.remove(target);
-
-            if (tickets.isEmpty()) {
-                iterator.remove();
-            }
+        synchronized (tickets) {
+	        for (java.util.Iterator<ArraySetSorted<Ticket<?>>> iterator = this.tickets.values().iterator(); iterator.hasNext();) {
+	            ArraySetSorted<Ticket<?>> tickets = iterator.next();
+	            tickets.remove(target);
+	
+	            if (tickets.isEmpty()) {
+	                iterator.remove();
+	            }
+	        }
         }
     }
     // CraftBukkit end
@@ -290,9 +300,11 @@ public abstract class ChunkMapDistance {
 
         @Override
         protected int b(long i) {
-            ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) ChunkMapDistance.this.tickets.get(i);
+        	synchronized (tickets) {
+        		ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) ChunkMapDistance.this.tickets.get(i);
 
-            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.b()).b());
+                return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.b()).b());
+			}
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 76c7f4a50..e5831d778 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -349,7 +349,7 @@ public class ChunkProviderServer extends IChunkProvider {
     @Override
     public IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag) {
         final int x = i; final int z = j; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.serverThread) {
+        if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // YAPFA
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 3a88c9a67..e7ed993ef 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -85,7 +85,7 @@ public class EntityTrackerEntry {
 
             if (this.tickCounter % 10 == 0 && itemstack.getItem() instanceof ItemWorldMap) { // CraftBukkit - Moved this.tickCounter % 10 logic here so item frames do not enter the other blocks
                 WorldMap worldmap = ItemWorldMap.getSavedMap(itemstack, this.b);
-                Iterator iterator = this.trackedPlayers.iterator(); // CraftBukkit
+                Iterator iterator = new HashSet<>(this.trackedPlayers).iterator(); // CraftBukkit
 
                 while (iterator.hasNext()) {
                     EntityPlayer entityplayer = (EntityPlayer) iterator.next();
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 692c0cac9..495eb7833 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -50,7 +50,14 @@ import java.util.Random;
 import java.util.UUID;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
@@ -70,6 +77,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import org.spigotmc.WatchdogThread;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable, Runnable {
 
@@ -1003,7 +1011,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
 
     }
 
-    private boolean canSleepForTick() {
+    boolean canSleepForTick() { // YAPFA
         // CraftBukkit start
         return this.forceTicks || this.isEntered() || SystemUtils.getMonotonicMillis() < (this.ac ? this.ab : this.nextTick);
     }
@@ -1194,6 +1202,29 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
 
+    // YAPFA start
+    
+    public static final ThreadFactory threadFactory = new ThreadFactory() {
+
+        private final AtomicInteger id = new AtomicInteger(0);
+
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread thread = new Thread(r);
+            thread.setName("ASYNC_WORLD_THREAD" + "_" + id.incrementAndGet());
+            de.tr7zw.yapfa.MainThreadHandler.registerThread(thread);
+            return thread;
+        }
+    };
+    
+    public final ExecutorService worldPool = new ThreadPoolExecutor(3, 50, 60, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<Runnable>(), MinecraftServer.threadFactory);
+    
+    public static long worldTick = 0;
+    public static boolean asyncWorlds = false;
+    
+    // YAPFA end
+    
     protected void b(BooleanSupplier booleansupplier) {
         MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
         this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
@@ -1235,48 +1266,72 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
 
-        while (iterator.hasNext()) {
-            WorldServer worldserver = (WorldServer) iterator.next();
-
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-            if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
-                this.methodProfiler.a(() -> {
-                    return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
-                });
-                /* Drop global time updates
-                if (this.ticks % 20 == 0) {
-                    this.methodProfiler.enter("timeSync");
-                    this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.worldProvider.getDimensionManager());
-                    this.methodProfiler.exit();
-                }
-                // CraftBukkit end */
-
-                this.methodProfiler.enter("tick");
-
-                try {
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick(booleansupplier);
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    CrashReport crashreport;
-                    try {
-                        crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t) {
-                        throw new RuntimeException("Error generating crash report", t);
-                    }
-                    // Spigot End
-
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
-                }
-
-                this.methodProfiler.exit();
-                this.methodProfiler.exit();
-                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
-            }
-        }
+        
+        // YAPFA start
+		if (de.tr7zw.yapfa.YapfaConfig.asyncWorldTick && !Timings.isTimingsEnabled()) {
+			asyncWorlds = true;
+			try {
+				worldTick = worldPool.invokeAll(new ArrayList<WorldServer>(this.worldServer.values())).parallelStream().mapToLong(f -> {
+					try {
+						return f.get();
+					} catch (InterruptedException e) {
+						e.printStackTrace();
+					} catch (ExecutionException e) {
+						e.printStackTrace();
+					}
+					return 100000;
+				}).sum();
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
+		} else {
+			asyncWorlds = false;
+			long start = System.currentTimeMillis();
+	        while (iterator.hasNext()) {
+	            WorldServer worldserver = (WorldServer) iterator.next();
+	
+	            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+	            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+	            if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
+	                this.methodProfiler.a(() -> {
+	                    return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
+	                });
+	                /* Drop global time updates
+	                if (this.ticks % 20 == 0) {
+	                    this.methodProfiler.enter("timeSync");
+	                    this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.worldProvider.getDimensionManager());
+	                    this.methodProfiler.exit();
+	                }
+	                // CraftBukkit end */
+	
+	                this.methodProfiler.enter("tick");
+	
+	                try {
+	                    worldserver.timings.doTick.startTiming(); // Spigot
+	                    worldserver.doTick(booleansupplier);
+	                    worldserver.timings.doTick.stopTiming(); // Spigot
+	                } catch (Throwable throwable) {
+	                    // Spigot Start
+	                    CrashReport crashreport;
+	                    try {
+	                        crashreport = CrashReport.a(throwable, "Exception ticking world");
+	                    } catch (Throwable t) {
+	                        throw new RuntimeException("Error generating crash report", t);
+	                    }
+	                    // Spigot End
+	
+	                    worldserver.a(crashreport);
+	                    throw new ReportedException(crashreport);
+	                }
+	
+	                this.methodProfiler.exit();
+	                this.methodProfiler.exit();
+	                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+	            }
+	        }
+	        worldTick = System.currentTimeMillis() - start;
+        }
+        // YAPFA end
 
         this.methodProfiler.exitEnter("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 57bea926a..981f31ad0 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -24,6 +24,7 @@ import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.HashMap; // Paper
+import java.util.HashSet;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -1644,7 +1645,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
 
         public void broadcast(Packet<?> packet) {
-            Iterator iterator = this.trackedPlayers.iterator();
+            Iterator iterator = new HashSet<>(this.trackedPlayers).iterator();
 
             while (iterator.hasNext()) {
                 EntityPlayer entityplayer = (EntityPlayer) iterator.next();
@@ -1663,7 +1664,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
 
         public void a() {
-            Iterator iterator = this.trackedPlayers.iterator();
+            Iterator iterator = new HashSet<>(this.trackedPlayers).iterator();
 
             while (iterator.hasNext()) {
                 EntityPlayer entityplayer = (EntityPlayer) iterator.next();
@@ -1739,7 +1740,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
 
         public void track(List<EntityPlayer> list) {
-            Iterator iterator = list.iterator();
+            Iterator iterator = new ArrayList<>(list).iterator();
 
             while (iterator.hasNext()) {
                 EntityPlayer entityplayer = (EntityPlayer) iterator.next();
diff --git a/src/main/java/net/minecraft/server/PlayerConnectionUtils.java b/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
index eb3269e0e..c2ff8f184 100644
--- a/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
+++ b/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
@@ -4,13 +4,23 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
+import co.aikar.timings.Timings;
 
 public class PlayerConnectionUtils {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
     public static <T extends PacketListener> void ensureMainThread(Packet<T> packet, T t0, WorldServer worldserver) throws CancelledPacketHandleException {
-        ensureMainThread(packet, t0, (IAsyncTaskHandler) worldserver.getMinecraftServer());
+        // YAPFA start
+		if (Timings.isTimingsEnabled() || packet instanceof PacketPlayInCustomPayload) {
+			ensureMainThread(packet, t0, (IAsyncTaskHandler) worldserver.getMinecraftServer());
+		} else {
+			if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) {
+				worldserver.packets.add(() -> packet.a(t0));
+				throw CancelledPacketHandleException.INSTANCE;
+			}
+		}
+    	// YAPFA end
     }
 
     public static <T extends PacketListener> void ensureMainThread(Packet<T> packet, T t0, IAsyncTaskHandler<?> iasynctaskhandler) throws CancelledPacketHandleException {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index baad98517..2b61d7f4f 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -42,7 +42,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
     protected final List<TileEntity> tileEntityListPending = Lists.newArrayList();
     protected final java.util.Set<TileEntity> tileEntityListUnload = com.google.common.collect.Sets.newHashSet();
-    public final Thread serverThread;
+    //public final Thread serverThread;
     private int c;
     protected int i = (new Random()).nextInt();
     protected final int j = 1013904223;
@@ -140,7 +140,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         this.chunkProvider = (IChunkProvider) bifunction.apply(this, this.worldProvider);
         this.isClientSide = flag;
         this.worldBorder = this.worldProvider.getWorldBorder();
-        this.serverThread = Thread.currentThread();
+        //this.serverThread = Thread.currentThread();
         this.biomeManager = new BiomeManager(this, flag ? worlddata.getSeed() : WorldData.c(worlddata.getSeed()), dimensionmanager.getGenLayerZoomer());
         // CraftBukkit start
         getWorldBorder().world = (WorldServer) this;
@@ -256,7 +256,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     @Override
     public Chunk getChunkAt(int i, int j) {
         // Paper start - optimise this for loaded chunks
-        if (Thread.currentThread() == this.serverThread) {
+        if (de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) {
             Chunk ifLoaded = ((WorldServer) this).getChunkProvider().getChunkAtIfLoadedMainThread(i, j);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -1028,7 +1028,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && !de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // YAPFA
             return null;
         } else {
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index c74b85917..191946376 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -22,6 +22,7 @@ import java.io.BufferedWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -31,6 +32,7 @@ import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
@@ -51,7 +53,8 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 
-public class WorldServer extends World {
+public class WorldServer extends World
+	implements Callable<Long> { // YAPFA
 
     private static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
@@ -221,7 +224,7 @@ public class WorldServer extends World {
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || !de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
@@ -2135,4 +2138,41 @@ public class WorldServer extends World {
             return structureboundingbox.b((BaseBlockPosition) blockactiondata.a());
         });
     }
+    
+    // YAPFA start
+    public List<Runnable> packets = new ArrayList<Runnable>();
+    
+	@Override
+	public Long call() throws Exception {
+		long start = System.currentTimeMillis();
+		List<Runnable> copy = new ArrayList<>(packets);
+		copy.forEach(r -> {
+			packets.remove(r);
+			r.run();
+		});
+        hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+        TileEntityHopper.skipHopperEvents = paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+
+        try {
+            doTick(server::canSleepForTick);
+        } catch (Throwable throwable) {
+            // Spigot Start
+            CrashReport crashreport;
+            try {
+                crashreport = CrashReport.a(throwable, "Exception ticking world");
+            } catch (Throwable t) {
+                throw new RuntimeException("Error generating crash report", t);
+            }
+            // Spigot End
+
+            a(crashreport);
+            throw new ReportedException(crashreport);
+        }
+
+        explosionDensityCache.clear(); // Paper - Optimize explosions
+		return System.currentTimeMillis() - start;
+	}
+	
+	// YAPFA end
+    
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index a14b8cb98..b7cd3b281 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -623,7 +623,10 @@ public class CraftWorld implements World {
     @Override
     public Collection<Plugin> getPluginChunkTickets(int x, int z) {
         ChunkMapDistance chunkDistanceManager = this.world.getChunkProvider().playerChunkMap.chunkDistanceManager;
-        ArraySetSorted<Ticket<?>> tickets = chunkDistanceManager.tickets.get(ChunkCoordIntPair.pair(x, z));
+        ArraySetSorted<Ticket<?>> tickets = null;
+        synchronized (chunkDistanceManager.tickets) {
+        	tickets = chunkDistanceManager.tickets.get(ChunkCoordIntPair.pair(x, z));
+		}
 
         if (tickets == null) {
             return Collections.emptyList();
@@ -644,22 +647,24 @@ public class CraftWorld implements World {
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         ChunkMapDistance chunkDistanceManager = this.world.getChunkProvider().playerChunkMap.chunkDistanceManager;
 
-        for (Long2ObjectMap.Entry<ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
-            long chunkKey = chunkTickets.getLongKey();
-            ArraySetSorted<Ticket<?>> tickets = chunkTickets.getValue();
-
-            Chunk chunk = null;
-            for (Ticket<?> ticket : tickets) {
-                if (ticket.getTicketType() != TicketType.PLUGIN_TICKET) {
-                    continue;
-                }
-
-                if (chunk == null) {
-                    chunk = this.getChunkAt(ChunkCoordIntPair.getX(chunkKey), ChunkCoordIntPair.getZ(chunkKey));
-                }
-
-                ret.computeIfAbsent((Plugin) ticket.identifier, (key) -> ImmutableList.builder()).add(chunk);
-            }
+        synchronized (chunkDistanceManager.tickets) {
+	        for (Long2ObjectMap.Entry<ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
+	            long chunkKey = chunkTickets.getLongKey();
+	            ArraySetSorted<Ticket<?>> tickets = chunkTickets.getValue();
+	
+	            Chunk chunk = null;
+	            for (Ticket<?> ticket : tickets) {
+	                if (ticket.getTicketType() != TicketType.PLUGIN_TICKET) {
+	                    continue;
+	                }
+	
+	                if (chunk == null) {
+	                    chunk = this.getChunkAt(ChunkCoordIntPair.getX(chunkKey), ChunkCoordIntPair.getZ(chunkKey));
+	                }
+	
+	                ret.computeIfAbsent((Plugin) ticket.identifier, (key) -> ImmutableList.builder()).add(chunk);
+	            }
+	        }
         }
 
         return ret.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, (entry) -> entry.getValue().build()));
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
index 166f4ee08..24dd1ea9f 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
@@ -18,23 +18,29 @@ public final class WeakCollection<T> implements Collection<T> {
     @Override
     public boolean add(T value) {
         Validate.notNull(value, "Cannot add null value");
-        return collection.add(new WeakReference<T>(value));
+        synchronized (collection) {
+        	return collection.add(new WeakReference<T>(value));
+		}
     }
 
     @Override
     public boolean addAll(Collection<? extends T> collection) {
-        Collection<WeakReference<T>> values = this.collection;
-        boolean ret = false;
-        for (T value : collection) {
-            Validate.notNull(value, "Cannot add null value");
-            ret |= values.add(new WeakReference<T>(value));
-        }
-        return ret;
+    	synchronized (collection) {
+	        Collection<WeakReference<T>> values = this.collection;
+	        boolean ret = false;
+	        for (T value : collection) {
+	            Validate.notNull(value, "Cannot add null value");
+	            ret |= values.add(new WeakReference<T>(value));
+	        }
+	        return ret;
+    	}
     }
 
     @Override
     public void clear() {
-        collection.clear();
+    	synchronized (collection) {
+    		collection.clear();
+    	}
     }
 
     @Override
@@ -42,17 +48,21 @@ public final class WeakCollection<T> implements Collection<T> {
         if (object  == null) {
             return false;
         }
-        for (T compare : this) {
-            if (object.equals(compare)) {
-                return true;
-            }
+        synchronized (collection) {
+	        for (T compare : this) {
+	            if (object.equals(compare)) {
+	                return true;
+	            }
+	        }
+	        return false;
         }
-        return false;
     }
 
     @Override
     public boolean containsAll(Collection<?> collection) {
-        return toCollection().containsAll(collection);
+    	synchronized (collection) {
+    		return toCollection().containsAll(collection);
+    	}
     }
 
     @Override
@@ -73,20 +83,22 @@ public final class WeakCollection<T> implements Collection<T> {
                     return true;
                 }
 
-                Iterator<WeakReference<T>> it = this.it;
-                value = null;
-
-                while (it.hasNext()) {
-                    WeakReference<T> ref = it.next();
-                    value = ref.get();
-                    if (value == null) {
-                        it.remove();
-                    } else {
-                        this.value = value;
-                        return true;
-                    }
+                synchronized (collection) {
+	                Iterator<WeakReference<T>> it = this.it;
+	                value = null;
+	
+	                while (it.hasNext()) {
+	                    WeakReference<T> ref = it.next();
+	                    value = ref.get();
+	                    if (value == null) {
+	                        it.remove();
+	                    } else {
+	                        this.value = value;
+	                        return true;
+	                    }
+	                }
+	                return false;
                 }
-                return false;
             }
 
             @Override
@@ -119,49 +131,57 @@ public final class WeakCollection<T> implements Collection<T> {
             return false;
         }
 
-        Iterator<T> it = this.iterator();
-        while (it.hasNext()) {
-            if (object.equals(it.next())) {
-                it.remove();
-                return true;
-            }
+        synchronized (collection) {
+	        Iterator<T> it = this.iterator();
+	        while (it.hasNext()) {
+	            if (object.equals(it.next())) {
+	                it.remove();
+	                return true;
+	            }
+	        }
+	        return false;
         }
-        return false;
     }
 
     @Override
     public boolean removeAll(Collection<?> collection) {
-        Iterator<T> it = this.iterator();
-        boolean ret = false;
-        while (it.hasNext()) {
-            if (collection.contains(it.next())) {
-                ret = true;
-                it.remove();
-            }
-        }
-        return ret;
+    	synchronized (collection) {
+	        Iterator<T> it = this.iterator();
+	        boolean ret = false;
+	        while (it.hasNext()) {
+	            if (collection.contains(it.next())) {
+	                ret = true;
+	                it.remove();
+	            }
+	        }
+	        return ret;
+    	}
     }
 
     @Override
     public boolean retainAll(Collection<?> collection) {
-        Iterator<T> it = this.iterator();
-        boolean ret = false;
-        while (it.hasNext()) {
-            if (!collection.contains(it.next())) {
-                ret = true;
-                it.remove();
-            }
-        }
-        return ret;
+    	synchronized (collection) {
+	        Iterator<T> it = this.iterator();
+	        boolean ret = false;
+	        while (it.hasNext()) {
+	            if (!collection.contains(it.next())) {
+	                ret = true;
+	                it.remove();
+	            }
+	        }
+	        return ret;
+    	}
     }
 
     @Override
     public int size() {
-        int s = 0;
-        for (T value : this) {
-            s++;
-        }
-        return s;
+    	synchronized (collection) {
+	        int s = 0;
+	        for (T value : this) {
+	            s++;
+	        }
+	        return s;
+    	}
     }
 
     @Override
@@ -175,10 +195,12 @@ public final class WeakCollection<T> implements Collection<T> {
     }
 
     private Collection<T> toCollection() {
-        ArrayList<T> collection = new ArrayList<T>();
-        for (T value : this) {
-            collection.add(value);
-        }
-        return collection;
+    	synchronized (collection) {
+	        ArrayList<T> collection = new ArrayList<T>();
+	        for (T value : this) {
+	            collection.add(value);
+	        }
+	        return collection;
+    	}
     }
 }
-- 
2.25.1.windows.1

