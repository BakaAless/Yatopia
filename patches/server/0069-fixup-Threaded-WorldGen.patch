From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sat, 23 Jan 2021 15:42:26 +0800
Subject: [PATCH] fixup! Threaded WorldGen


diff --git a/src/main/java/net/minecraft/server/ChunkStatus.java b/src/main/java/net/minecraft/server/ChunkStatus.java
index 4afba15d01e86e64ddec3f599a04b7f9afd20b91..8daeba67717d65a558fb40e5aaf0f24276cc4588 100644
--- a/src/main/java/net/minecraft/server/ChunkStatus.java
+++ b/src/main/java/net/minecraft/server/ChunkStatus.java
@@ -28,26 +28,27 @@ public class ChunkStatus {
             new LinkedBlockingQueue<>(),
             new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks FeatureGen Worker #%d").build()
     );
-    private static final ThreadPoolExecutor structureGenExecutor = new ThreadPoolExecutor(
-            1,
+    private static final ThreadPoolExecutor worldGenExecutor = new ThreadPoolExecutor(
+            Math.min(Runtime.getRuntime().availableProcessors(), Integer.getInteger("paper.maxChunkThreads", 8)),
             Math.min(Runtime.getRuntime().availableProcessors(), Integer.getInteger("paper.maxChunkThreads", 8)),
             60,
             TimeUnit.SECONDS,
             new LinkedBlockingQueue<>(),
-            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks StructureGen Worker #%d").build()
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks WorldGen Worker #%d").build()
     );
+
     static void shutdownExecutors() {
         featureGenExecutor.shutdown();
-        structureGenExecutor.shutdown();
+        worldGenExecutor.shutdown();
         while (!featureGenExecutor.isTerminated()) {
             try {
                 featureGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
             } catch (InterruptedException ignored) {
             }
         }
-        while (!structureGenExecutor.isTerminated()) {
+        while (!worldGenExecutor.isTerminated()) {
             try {
-                structureGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
+                worldGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
             } catch (InterruptedException ignored) {
             }
         }
@@ -67,8 +68,7 @@ public class ChunkStatus {
     });
     public static final ChunkStatus STRUCTURE_STARTS = a("structure_starts", ChunkStatus.EMPTY, 0, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
         // Yatopia start - threaded WorldGen
-        return chunkgenerator.structureGenLock.acquireLock().toCompletableFuture().thenComposeAsync(lockToken -> {
-        try {
+        return CompletableFuture.supplyAsync(() -> {
         if (!ichunkaccess.getChunkStatus().b(chunkstatus)) {
             if (worldserver.worldDataServer.getGeneratorSettings().shouldGenerateMapFeatures()) { // CraftBukkit
                 chunkgenerator.createStructures(worldserver.r(), worldserver.getStructureManager(), ichunkaccess, definedstructuremanager, worldserver.getSeed());
@@ -78,11 +78,8 @@ public class ChunkStatus {
                 ((ProtoChunk) ichunkaccess).a(chunkstatus);
             }
         }
-        } finally {
-            lockToken.releaseLock();
-        }
-        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
-        }, structureGenExecutor);
+        return Either.left(ichunkaccess);
+        }, worldGenExecutor);
         // Yatopia end
     });
     public static final ChunkStatus STRUCTURE_REFERENCES = a("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (worldserver, chunkgenerator, list, ichunkaccess) -> {
@@ -309,7 +306,7 @@ public class ChunkStatus {
                 }
             }
             return Either.left(ichunkaccess);
-            }, SystemUtils.getMainThreadExecutor());
+            }, worldGenExecutor);
 
             // Yatopia end
         }
diff --git a/src/main/java/net/minecraft/server/GenLayers.java b/src/main/java/net/minecraft/server/GenLayers.java
index 7abf0e4b7e96dd367b9d03cbc62ac7bb03542d0a..124eb6bf2cbffd642e7516ad485a95482b6e7402 100644
--- a/src/main/java/net/minecraft/server/GenLayers.java
+++ b/src/main/java/net/minecraft/server/GenLayers.java
@@ -6,7 +6,7 @@ import java.util.function.LongFunction;
 
 public class GenLayers {
 
-    private static final Int2IntMap a = (Int2IntMap) SystemUtils.a((Object) (new Int2IntOpenHashMap()), (int2intopenhashmap) -> {
+    private static final Int2IntMap a = (Int2IntMap) SystemUtils.a((new Int2IntOpenHashMap()), (int2intopenhashmap) -> { // Yatopia - decompile fix
         a(int2intopenhashmap, GenLayers.Type.BEACH, 16);
         a(int2intopenhashmap, GenLayers.Type.BEACH, 26);
         a(int2intopenhashmap, GenLayers.Type.DESERT, 2);
@@ -154,6 +154,10 @@ public class GenLayers {
         return new GenLayer(areafactory);
     }
 
+    public static ThreadLocal<GenLayer> genLayerThreadLocal(long i, boolean flag, int j, int k) {
+        return ThreadLocal.withInitial(() -> new GenLayer(a(flag, j, k, (l) -> new WorldGenContextArea(25, i, l))));
+    }
+
     public static boolean a(int i, int j) {
         return i == j ? true : GenLayers.a.get(i) == GenLayers.a.get(j);
     }
diff --git a/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java b/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java
index d98ac030e205dbb1512ef6b837e2f3fdd208e231..6ca4d5cf6e352485069af8555e898fb9f7007835 100644
--- a/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java
+++ b/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java
@@ -19,7 +19,7 @@ public class WorldChunkManagerOverworld extends WorldChunkManager {
             return worldchunkmanageroverworld.k;
         })).apply(instance, instance.stable(WorldChunkManagerOverworld::new));
     });
-    private final GenLayer f;
+    private final ThreadLocal<GenLayer> f;
     private static final List<ResourceKey<BiomeBase>> g = ImmutableList.of(Biomes.OCEAN, Biomes.PLAINS, Biomes.DESERT, Biomes.MOUNTAINS, Biomes.FOREST, Biomes.TAIGA, Biomes.SWAMP, Biomes.RIVER, Biomes.FROZEN_OCEAN, Biomes.FROZEN_RIVER, Biomes.SNOWY_TUNDRA, Biomes.SNOWY_MOUNTAINS, new ResourceKey[]{Biomes.MUSHROOM_FIELDS, Biomes.MUSHROOM_FIELD_SHORE, Biomes.BEACH, Biomes.DESERT_HILLS, Biomes.WOODED_HILLS, Biomes.TAIGA_HILLS, Biomes.MOUNTAIN_EDGE, Biomes.JUNGLE, Biomes.JUNGLE_HILLS, Biomes.JUNGLE_EDGE, Biomes.DEEP_OCEAN, Biomes.STONE_SHORE, Biomes.SNOWY_BEACH, Biomes.BIRCH_FOREST, Biomes.BIRCH_FOREST_HILLS, Biomes.DARK_FOREST, Biomes.SNOWY_TAIGA, Biomes.SNOWY_TAIGA_HILLS, Biomes.GIANT_TREE_TAIGA, Biomes.GIANT_TREE_TAIGA_HILLS, Biomes.WOODED_MOUNTAINS, Biomes.SAVANNA, Biomes.SAVANNA_PLATEAU, Biomes.BADLANDS, Biomes.WOODED_BADLANDS_PLATEAU, Biomes.BADLANDS_PLATEAU, Biomes.WARM_OCEAN, Biomes.LUKEWARM_OCEAN, Biomes.COLD_OCEAN, Biomes.DEEP_WARM_OCEAN, Biomes.DEEP_LUKEWARM_OCEAN, Biomes.DEEP_COLD_OCEAN, Biomes.DEEP_FROZEN_OCEAN, Biomes.SUNFLOWER_PLAINS, Biomes.DESERT_LAKES, Biomes.GRAVELLY_MOUNTAINS, Biomes.FLOWER_FOREST, Biomes.TAIGA_MOUNTAINS, Biomes.SWAMP_HILLS, Biomes.ICE_SPIKES, Biomes.MODIFIED_JUNGLE, Biomes.MODIFIED_JUNGLE_EDGE, Biomes.TALL_BIRCH_FOREST, Biomes.TALL_BIRCH_HILLS, Biomes.DARK_FOREST_HILLS, Biomes.SNOWY_TAIGA_MOUNTAINS, Biomes.GIANT_SPRUCE_TAIGA, Biomes.GIANT_SPRUCE_TAIGA_HILLS, Biomes.MODIFIED_GRAVELLY_MOUNTAINS, Biomes.SHATTERED_SAVANNA, Biomes.SHATTERED_SAVANNA_PLATEAU, Biomes.ERODED_BADLANDS, Biomes.MODIFIED_WOODED_BADLANDS_PLATEAU, Biomes.MODIFIED_BADLANDS_PLATEAU});
     private final long h;
     private final boolean i;
@@ -36,7 +36,7 @@ public class WorldChunkManagerOverworld extends WorldChunkManager {
         this.i = flag;
         this.j = flag1;
         this.k = iregistry;
-        this.f = GenLayers.a(i, flag, flag1 ? 6 : 4, 4);
+        this.f = GenLayers.genLayerThreadLocal(i, flag, flag1 ? 6 : 4, 4);
     }
 
     @Override
@@ -46,6 +46,6 @@ public class WorldChunkManagerOverworld extends WorldChunkManager {
 
     @Override
     public BiomeBase getBiome(int i, int j, int k) {
-        return this.f.a(this.k, i, k);
+        return this.f.get().a(this.k, i, k);
     }
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 40e87f3043da14b1265fcdadde02bef3b261a9d1..07f7b1345e4e13ba55783b764d14b9ef5d4db139 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -2548,28 +2548,24 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
         // Paper start
         BlockPosition blockposition1 = blockposition.immutableCopy();
-        this.getMinecraftServer().execute(() -> {
+        this.chunkProvider.serverThreadQueue.execute(() -> {
                 if (!optional.isPresent() && this.getPoiStorage().test(blockposition1, com.google.common.base.Predicates.alwaysTrue())) {
                     this.getPoiStorage().remove(blockposition1);
                 }
-        });
         if (!Objects.equals(optional, optional1)) {
             //BlockPosition blockposition1 = blockposition.immutableCopy();
             // Paper end
 
             optional.ifPresent((villageplacetype) -> {
-                this.getMinecraftServer().execute(() -> {
                     this.y().a(blockposition1);
                     PacketDebug.b(this, blockposition1);
-                });
             });
             optional1.ifPresent((villageplacetype) -> {
-                this.getMinecraftServer().execute(() -> {
                     this.y().a(blockposition1, villageplacetype);
                     PacketDebug.a(this, blockposition1);
-                });
             });
         }
+        });
     }
 
     public final VillagePlace getPoiStorage() { return this.y(); } // Paper - OBFHELPER
